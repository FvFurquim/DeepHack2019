# -*- coding: utf-8 -*-
"""projetoajudaessescornodesãopaulo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AkJrzBXsGlFs0YxXy_8m0Uul1A9GfXn_

## 1 - Fazer uma relação entre as respostas do quiz e o quanto o município gasta
## 2 - Descobrir o melhor caso, ou seja, a cidade mais eficiente nesse aspecto (por ano)
## 3 - Dar sugestões
"""

import pandas as pd
from zipfile import ZipFile
import io
from io import BytesIO
import urllib.request 
import json 
from urllib.request import urlopen
import numpy as np
import unicodedata

endereco = "https://transparencia.tce.sp.gov.br/iegm-deephack2019"
arquivo = urlopen(endereco)
zipfile = ZipFile(BytesIO(arquivo.read())) 
df = pd.read_csv(zipfile.open('iegm.csv'),encoding='latin-1',error_bad_lines = False, sep=';')

from google.colab import files

import matplotlib.pyplot as plt

"""# Dados gerais(todas as perguntas):"""

df.head(10)

#Filtragem ambiental
ambdf = df[df['indice'] == 'i-Amb']

#Base de dados que atribui valor às respostas:
respostas = files.upload()
resdb = pd.read_excel(BytesIO(respostas['20190924-IEGM_cadastro_ODS_v2.xlsx']))
resdb = resdb.drop(columns =['ods_condicao_resposta_operador', 'ods_condicao_resposta_referencial' , 'iegm_indice_ordem_interna', 'iegm_pergunta_tipo'])
resdb = resdb.drop_duplicates(subset='iegm_opcao_resposta_codigo', keep='last')

"""## A partir daqui, tudo é para contar o número de respostas por pergunta por tipo de resposta(não utilizado)"""

#@title
resdb = resdb[resdb.ods_influencia != '<null>']

#@title
respcoredf = df.drop(columns=['cod_ibge', 'municipio', 'porte', 'ano_exercicio', 'valor_resposta', 'texto_pergunta_genérica', 'rotulo_resposta', 'cod_resposta'])
respcoredf = respcoredf.drop_duplicates(subset='cod_pergunta', keep='last')
respcoredf['res_positivas'] = 0
respcoredf['res_neutras'] = 0
respcoredf['res_negativas'] = 0
respcoredf = respcoredf.set_index('cod_pergunta')

#@title
respcoredf.head(50)

#@title
respcoredf.set_value('M01Q01401', 'res_positivas', 0)

#@title
respcoredf.shape

#@title
def respostastotais(codpergunta, valresposta, respcoredf, resdb):  
  if codpergunta in resdb.values:
    if valresposta in resdb.values:
      templine = resdb.query('iegm_opcao_resposta_codigo == "{}"'.format(valresposta))
      if ((np.where(templine['ods_influencia'] == "positiva",True,False)).item(0)):
        respcoredf.set_value('{}'.format(codpergunta), 'res_positivas', (respcoredf.at['{}'.format(codpergunta), 'res_positivas'])+ 1 ) 
      if ((np.where(templine['ods_influencia'] == "neutra",True,False)).item(0)):
        respcoredf.set_value('{}'.format(codpergunta), 'res_neutras', (respcoredf.at['{}'.format(codpergunta), 'res_neutras'])+ 1 )
      if ((np.where(templine['ods_influencia'] == "negativa",True,False)).item(0)):
        respcoredf.set_value('{}'.format(codpergunta), 'res_negativas', (respcoredf.at['{}'.format(codpergunta), 'res_negativas'])+ 1 )

#@title

files.download()

#@title
df.apply(lambda row: respostastotais(row['cod_pergunta'], row['cod_resposta'],respcoredf, resdb), axis=1)

#@title
#Ok, hora dos testes.
testedf = df.head(10)
testedf.head(10)

#@title
testedf.apply(lambda row: respostastotais(row['cod_pergunta'], row['cod_resposta'],respcoredf ,resdb), axis=1)

#@title
respcoredf.loc['M01Q05000']

#@title
respcoredf.to_csv('respcore.csv', sep = ';', encoding = 'latin-1')
files.download('respcore.csv')

"""# Aqui para contar o número de respostas de cada tipo por município:"""

#@title
muniscoredb = df.drop_duplicates(subset = ['municipio'], keep = 'last')
muniscoredb = muniscoredb.drop(columns=['ano_exercicio','cod_pergunta', 'valor_resposta', 'texto_pergunta_genérica', 'rotulo_resposta', 'cod_resposta', 'indice'])
muniscoredb = muniscoredb.sort_values('municipio')
muniscoredb['res_positivas'] = 0
muniscoredb['res_neutras'] = 0
muniscoredb['res_negativas'] = 0
muniscoredb = muniscoredb.set_index('municipio')

#@title
pydeadb.loc['Adolfo']

#@title
def respostascidade(municipionome, muniscoredb, resdb, df): 
  tempdf = df.loc[df['municipio'] == municipionome] 
  tempdf.apply(lambda row: compare(municipionome, row['cod_pergunta'], row['cod_resposta'], muniscoredb, resdb), axis = 1 )

#@title
def compare(municipio, codpergunta, valresposta, muniscoredb, resdb):
  if codpergunta in resdb.values:
    if valresposta in resdb.values:
      templine = resdb.query('iegm_opcao_resposta_codigo == "{}"'.format(valresposta))
      if ((np.where(templine['ods_influencia'] == "positiva",True,False)).item(0)):
        muniscoredb.set_value('{}'.format(municipio), 'res_positivas', (muniscoredb.at['{}'.format(municipio), 'res_positivas'])+ 1 )  
      if ((np.where(templine['ods_influencia'] == "neutra",True,False)).item(0)):
        muniscoredb.set_value('{}'.format(municipio), 'res_neutras', (muniscoredb.at['{}'.format(municipio), 'res_neutras'])+ 1 )
      if ((np.where(templine['ods_influencia'] == "negativa",True,False)).item(0)):
        muniscoredb.set_value('{}'.format(municipio), 'res_negativas', (muniscoredb.at['{}'.format(municipio), 'res_negativas'])+ 1 )

#@title
#Hora da verdade parte 2:
respostascidade('Jundiaí', muniscoredb, resdb, df)

"""# Atribuindo os valores a uma tabela e baixando-a para ser usada no PyDEA:"""

#@title
pydeadb = muniscoredb
pydeadb['vl_arrecadacao'] = 0
pydeadb['vl_despesa'] = 0

#@title
def somararrecadacao(nome, pydeadb): 
  tempnome = nome.lower()
  #tempnome = tempnome.decode('latin-1')
  jsonAddresso = "https://transparencia.tce.sp.gov.br/api/json/receitas/alpha/2018/1"
  jsonAddresso.replace("alpha", nome)
  tempdb1 = pd.read_json(jsonAddresso)  
  tirarformat(tempdb1)
  #pydeadb.set_value('{}'.format(nome), 'vl_receita', float(tempdb1['vl_arrecadacao'].sum()))

#@title
def tirarformat(tempdb):
  tempdb['vl_arrecadacao'] = (tempdb['vl_arrecadacao'].str.split()).apply(lambda x: (x[0].replace('.', '')))
  tempdb['vl_arrecadacao'] = (tempdb['vl_arrecadacao'].str.split()).apply(lambda x: float(x[0].replace(',', '.')))

#@title
count = 1
for nome in pydeadb.index:
  #somararrecadacao(nome, pydeadb)
  respostascidade(nome, pydeadb, resdb, ambdf)
  print(count)
  count += 1

#@title
pydeadb.head(10)

#@title
pydeadb.to_csv('pydeadb.csv', sep = ';', encoding = 'latin-1')
files.download('pydeadb.csv')

"""# Usando os resultados do PyDEA:"""

testedf = ambdf.query('municipio == "Adolfo"')
testedf.head(5)

def pegarnegativas(codresposta, codpergunta, resdb, df):
  if codresposta in resdb.values:
    templine = resdb.loc[resdb['iegm_opcao_resposta_codigo'] == codresposta]
    if((np.where(templine['ods_influencia'] == "negativa",True,False)).item(0)):      
      print(codpergunta)

def pegarpositivas(codresposta, codpergunta, resdb, df):
  if codresposta in resdb.values:
    templine = resdb.loc[resdb['iegm_opcao_resposta_codigo'] == codresposta]
    if((np.where(templine['ods_influencia'] == "positiva",True,False)).item(0)):      
      print(codpergunta)

"""**A partir daqui: Gambiarra**"""

testedf.apply(lambda row: pegarnegativas(row['cod_resposta'],row['cod_pergunta'],resdb, testedf), axis=1)
print("end")

testedf.shape

modelodf = ambdf.query('municipio == "Santos"')

modelodf.apply(lambda row: pegarpositivas(row['cod_resposta'],row['cod_pergunta'],resdb, testedf), axis=1)
print("end")

adolfoproblems = files.upload()
adolfop = pd.read_excel(BytesIO(adolfoproblems['respostascampinas.xlsx']))

def cruzamentos(pergunta, db):
  if pergunta in db.perguntasmodelo.values:
    templine = db.loc[db['perguntasmodelo'] == pergunta]
    if((np.where(templine['perguntasmodelo'] == pergunta,True,False)).item(0)):
      print(pergunta)

adolfop.apply(lambda row: cruzamentos(row['perguntaspesquisadas'], adolfop), axis=1)
print("end")

txtdavez = files.upload()
erros = pd.read_csv(BytesIO(txtdavez['errosadolfo.txt']),sep=" ", header=None)

for value in erros.values:  
  line = testedf.loc[testedf['cod_pergunta'] == value[0]]
  line = line.drop_duplicates(subset='cod_pergunta', keep='last')  
  print(line['texto_pergunta_genérica'].value_counts())
  print(line['valor_resposta'])

erros.values